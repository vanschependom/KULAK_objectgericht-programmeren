package model.oefening2.deck;import java.util.*;import model.oefening2.card.Card;/** * A class of decks containing cards *  * @invar  The number of cards on a deck cannot be negative,  *         nor can it exceed the capacity of the deck. *         As a consequence, the capacity of a card deck cannot *         be negative *         | (getNbCards() >= 0) && (getNbCards() <= getCapacity()) * @invar  Each object stored in a card deck must be an effective card. *         | for each i in 0..getNbCards(): *         |   getCardAt(i) != null * @invar  No card can be pushed on a card deck more than once. *         | for each i in 0..getNbCards(): *         |   for each j in 0..getNbCards(): *         |     if (i != j) *         |       then getCardAt(i) != getCardAt(j) * */public abstract class CardDeck {    /**     * The array containing all the cards in this card deck.     *      * @invar  The number of effective cards in the array     *         is restricted by its capacity.     *         | 0 <= length <= cards.length     * @invar  The array of cards is effective.     *         | cards <> null     * @invar  Cards are stored in order, with the bottom     *         card at the leftmost position in the array.     *         | for each i in 0..length-1:     *         |   cards[i] = getCardAt(i + 1)     */    private final Card[] cards;        private int length;            /**     * Initialize a new empty card deck.     *      * @param     capacity     *            The maximum number of cards ever on the new card deck.     * @pre       The given capacity may not be negative.     *            | capacity >= 0     * @effect    The capacity of the new card deck is set to the     *            given capacity.     *            | getCapacity() = capacity     * @effect    The new card deck does not contain any cards.     *            | getNbCards() = 0     */    protected CardDeck(int capacity) {        cards = new Card[capacity];    }    /**     * Push the given card on top of this card deck.     *      * @param   card  The card to be added on top of this card deck.     * @effect  The given card is added on top of this card deck.     *          | getNbCards = old.getNbCards() + 1     *          | getTop() = card     * @throws  IllegalStateException     *          The given card cannot be added on top of this card deck.     *          | not canHaveAsTop(card)     */    public void push(Card card) throws IllegalStateException {        if (!canHaveAsTop(card)) {            throw new IllegalStateException("Invalid top card!");        } else {            addCard(card);        }    }        /**     * Remove the card on top of this card deck.     *      * @effect  The card on top of this card deck is removed.     *          | getNbCards() = old.getNbCards() - 1     * @throws  IllegalStateException     *          This card deck has reached its minimal size.     *          | hasMinimalSize()     */    public void pop() throws IllegalStateException {        if (hasMinimalSize()) {            throw new IllegalStateException("Insufficient cards left!");        } else {            removeCard();        }    }    /**     * Return the maximum number of cards that can be put     * on this card deck.     */    public int getCapacity() {        return this.cards.length;    }        /**     * Return the number of cards on this card deck.     */    public int getNbCards() {        return this.length;    }        /**     * Check wether this card deck is fully loaded with cards.     *      * @return  True if the number of cards on this card deck     *          is equal to its capacity; false otherwise.     *          | getNbCards() = getCapacity()     */    public boolean hasMaximalSize() {        return getNbCards() == getCapacity();    }        /**     * Return the card at the given position in this card deck.     * For this method, cards on a deck are numbered starting     * from 1 for the card at the bottom of the deck.     *      * @param   index  The position of the card to be returned.     * @return  The card at the given position.     * @throws  IndexOutOfBoundsException     *          The given index is out of range.     *          | (index < 1) or (index > getNbCards())     */    public Card getCardAt(int index) throws IndexOutOfBoundsException {        if (index > getNbCards()) {            throw new IndexOutOfBoundsException("Index too high!");        } else {            return cards[index - 1];        }    }    /**     * Return the card on top of this card deck.     *      * @return  The card on top of this card deck.     *          | getCardAt(getNbCards())     * @throws  IllegalStateException     *          This card deck is empty.     *          | getNbCards() = 0     */    public Card getTop() throws IllegalStateException {        try {            return getCardAt(getNbCards());        } catch (IndexOutOfBoundsException exc) {            throw new IllegalStateException("No top card for an empty deck!");        }    }    /**     * Check whether the given card is loaded on this card deck.     *      * @param   card  The card to be verified     * @return  True if the given card is loaded at som position     *          on this card deck; false otherwise.     *          | for some i in 1..getNbCards():     *          |   getCardAt(i) = card     */    public boolean contains(Card card) {        int i = 1;                while ((i <= getNbCards()) && (getCardAt(i) != card)) {            i++;        }                return i <= getNbCards();    }            /**     * Check whether the given card can be added on top of this card deck.     *      * @param   card  The card to be verified.     * @return  True if this deck is not fully loaded with card, if the     *          given card is effective, and if that card is not already     *          loaded on this card deck; false otherwise.     *          | (not hasMaximalSize()) and (card <> null)     *          |  and (not contains(card))     */    public boolean canHaveAsTop(Card card) {        return (!hasMaximalSize()) && (card != null) && (!contains(card));    }        /**     * Return the cards stored in this card deck, with the card on top     * of this card deck at the end of the resulting list.     *      * @return  The length of the resulting list is     *          set to the number of cards in this card deck.     *          | (result.size() = getNbCards())     *          Successive elements in the resulting list correspond with     *          cards at corresponding positions in this card deck.     *          | for each i in 1..getNbCards():     *          |   result.getElement(i - 1) = getCardAt(i)     */    public List<Card> getCards() {        List<Card> result = new ArrayList<>();                for (int i = 1; i <= this.getNbCards(); i++) {            result.add(this.getCardAt(i));        }                return result;    }            /**     * Add the given card on top of this card deck.     *      * @param   card  The card to be added on top of this card deck.     * @effect  The given card is added on top of this card deck.     *          | getNbCards() = old.getNbCards() + 1     *          | getTop() = card     * @throws  IndexOutOfBoundsException     *          This card deck is already completely filled.     *          | hasMaximalSize()     */    protected void addCard(Card card) throws IndexOutOfBoundsException {        cards[length] = card;        length++;    }        /**     * Remove the card on top of this card deck.     *      * @effect  The card on top of this card deck is removed.     *          | getNbCards() = old.getNbCards() - 1     * @throws  IndexOutOfBoundsException     *          This card deck is empty.     *          | (getNbCards() = 0)     */    protected void removeCard() throws IndexOutOfBoundsException {        // It is not really needed to register a null reference        // at the position of the card to be removed. It is,        // however, a simple way to throw the exception.        cards[--length] = null;    }    /**     * Move the card on top of this deck on top of the     * given card deck.     *     * @param   target  The target deck for the transfer.     * @effect  The card on top of this deck is removed.     *          | getNbCards() = old.getNbCards() - 1     * @effect  The card on top of this deck is added on     *          top of the given target deck.     *          | target.getNbCards() = (old target).getNbCards() + 1     *          | target.getTop() = card     * @throws  IllegalStateException     *          This deck has reached its minimal size.     *          | hasMinimalSize()     * @throws  IllegalStateException     *          The card on top of this deck does not     *          match on top of the given target deck.     *          | not top.matchesOn(target)     */    public void moveTop(TargetDeck target) throws IllegalStateException {        if (hasMinimalSize() || (!topMatchesOn(target))) {            throw new IllegalStateException("Illegal move!");        } else {            target.push(getTop());            pop();        }    }    /**     * Move the top card of this deck to the help deck.     * By default, this will not be allowed and therefore     * not do anything     *     * @param helpDeck The help deck for the transfer.     * @effect  The card on top of this deck is removed.     *          | getNbCards() = old.getNbCards() - 1     * @effect  The card on top of this deck is added on     *          top of the given help deck.     *          | helpDeck.getNbCards() = (old helpDeck).getNbCards() + 1     *          | helpDeck.getTop() = card     * @throws  IllegalStateException     *          This deck has reached its minimal size.     *          | hasMinimalSize()     * @throws  IllegalStateException     *          The card on top of this deck does not     *          match on top of the given help deck.     *          | not top.matchesOn(helpDeck)     */    public void moveTop(HelpDeck helpDeck) {        if (hasMinimalSize() || (!topMatchesOn(helpDeck))) {            throw new IllegalStateException("Illegal move!");        } else {            helpDeck.push(getTop());            pop();        }    }    /**     * Check whether the card on top of this deck can be     * added on top of the given target deck.     *     * @param   target     *          The deck upon which the top card should fit.     * @return  False if this deck has reached its minimal     *          size, if the given target deck is not effective,     *          or if the target deck can not have the card on top     *          of this deck as its own top; undetermined     *          otherwise.     *          | if (hasMinimalSize())     *          |   result = false     *          | if (target = null)     *          |   result = false     *          | if (target.canHaveAsTop(getTop()))     *          |   result = false     */    public abstract boolean topMatchesOn(TargetDeck target);    /**     * Check whether the card on top of this deck can be     * added on top of the given help deck.     *     * @param   helpDeck     *          The deck upon which the top card should fit.     * @return  False if this deck has reached its minimal     *          size, if the given help deck is not effective,     *          or if the help deck can not have the card on top     *          of this deck as its own top; undetermined     *          otherwise.     *          | if (hasMinimalSize())     *          |   result = false     *          | if (helpDeck = null)     *          |   result = false     *          | if (helpDeck.canHaveAsTop(getTop()))     *          |   result = false     */    public abstract boolean topMatchesOn(HelpDeck helpDeck);    /**     * Check whether this deck has reached its     * minimal size.     *     * @return  True if no cards are loaded on this deck;     *          false otherwise.     *          | getNbCards() = 0     */    public boolean hasMinimalSize() {        return getNbCards() == 0;    }}