package deck;import card.Card;/** * A class of target decks containing cards. *    See superclass. * * @invar  A target deck cannot be empty. *         | getNbCards() >= 1 */public class TargetDeck extends CardDeck {    /**     * Initialize a new target deck with a single card on top of it.     *     * @param     capacity     *            The maximum number of cards allowed on the new     *            target deck.     * @param     card     *            The first card that has to be put on top of the     *            new target deck.     * @pre       The given capacity must be positive.     *            | capacity > 0     * @effect    The capacity of the new target deck is set to the     *            given capacity.     *            | getCapacity() = capacity     * @effect    The given card is the only card stored in the new     *            target deck.     *            | (getNbCards() = 1) and (getTop() = card)     * @throws    IllegalArgumentException     *            The given card is not effective.     *            | card = null     *     */    public TargetDeck(int capacity, Card card) throws IllegalArgumentException {        super(capacity);        if (card == null) {            throw new IllegalArgumentException("Non effective card!");        } else {            this.addCard(card);        }    }    /**     * Check whether this target deck has reached its minimal size.     *     * @return  True if only one card is loaded on this target deck;     *          false otherwise.     *          | getNbCards() = 1     */    public boolean hasMinimalSize() {        return getNbCards() == 1;    }    @Override    public boolean topMatchesOn(TargetDeck target) {        return false;    }    @Override    public boolean topMatchesOn(HelpDeck helpDeck) {        try {            return (!this.hasMinimalSize()) && (!helpDeck.hasMaximalSize());        } catch (NullPointerException exc) {            return false;        }    }    /**     * Return the card on top of this target deck.     *     * @return  The card on top of this target deck.     */    public Card getTop() {        return getCardAt(getNbCards());    }    /**     * Remove the card on top of this target deck.     *     * @effect  The card on top of this card deck is removed.     *          | getNbCards() = old.getNbCards() - 1     * @throws  IllegalStateException     *          This target deck only has one card.     *          | (getNbCards() = 1)     */    protected void removeCard() throws IllegalStateException {        if (hasMinimalSize()) {            throw new IllegalStateException("Target deck cannot be empty!");        } else {            super.removeCard();        }    }}