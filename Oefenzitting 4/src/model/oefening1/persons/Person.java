package model.oefening1.persons;import java.math.BigDecimal;import java.math.BigInteger;import java.util.HashSet;import java.util.NoSuchElementException;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.Stream;import model.oefening1.ownings.Car;import model.oefening1.ownings.Dog;import model.oefening1.ownings.Ownable;import model.oefening1.ownings.Painting;import be.kuleuven.cs.som.annotate.Raw;import model.oefening1.exceptions.IllegalOwnerException;/** * A class of persons involving a relation with things they own. *  * @invar   Each person can have each of its ownings as *          its owning. *          | for each ownable in Ownable: *          |   if (hasAsOwning(ownable) *          |     then canHaveAsOwning(ownable) */public class Person {	/**	 * Variable referencing a set collecting all the ownings of	 * this person.	 * 	 * @invar   The referenced sets are effective, if and only if this	 *          person is terminated.	 *          | (dogs == null && paintings == null && cars == null) == (this.isTerminated())	 * @invar   Each ownable registered in the referenced sets is	 *          effective.	 *          | if (dogs != null)	 *          |   then (! dogs.contains(null))	 *          | if (paintings != null)   	 *          |   then (! paintings.contains(null))   	 *          | if (cars != null)   	 *          |   then (! cars.contains(null))	 * @invar   Each ownable registered in the referenced sets is	 *          not yet terminated.	 *          | for each ownable in getOwnings():	 *          |     (!ownable.isTerminated())	 */	private Set<Dog> dogs = new HashSet<>();	private Set<Painting> paintings = new HashSet<>();	private Set<Car> cars = new HashSet<>();		/**	 * Initialize this new person with no ownings.	 *	 * @post    This new person has no ownings.	 *          | new.getNbOwnings() == 0	 * @post    This new person is not terminated.	 *          | ! new.isTerminated()	 */	public Person() {}	/**	 * Check whether this person has been terminated.	 */	@Raw	public boolean isTerminated() {		return (this.dogs == null && this.paintings == null && this.cars == null);	}	/**	 * Terminate this person.	 *	 * @post    This person is terminated.	 *          | new.isTerminated()	 * @post    Each of the ownings of this person no longer has	 *          an owner.	 *          | for each ownable in getOwnings():	 *          |	if (this.hasAsOwning(ownable)	 *          |     then (! (new ownable).hasOwner())	 */	public void terminate() {		if (!isTerminated()) {			for (Ownable ownable : this.getOwnings()) {				ownable.removeOwner();			}			setIsTerminated();		}	}	/**	 * Set the terminated-state for this person according to true.	 * 	 * @post    The terminated-state of this person is true.	 *          | new.isTerminated() == true	 */	protected void setIsTerminated() {		this.dogs = null;		this.paintings = null;		this.cars = null;	}	/**	 * Check whether this person has the given ownable as one of	 * its ownings.	 *	 * @param   ownable  The ownable to check.	 */	@Raw	public boolean hasAsOwning(Ownable ownable) {		return this.getOwnings().contains(ownable);	}	/**	 * Check whether this person can have the given ownable	 * as one of its ownings.	 * 	 * @param   ownable	 *          The ownable to check.	 * @return  True if the given ownable is effective, if that	 *          ownable can have this person as its owner, and either	 *          this person does not have the given ownable as one of	 *          its ownings or the given ownable references this	 *          person as its owner; false otherwise.	 *          | result ==	 *          |   (ownable != null) &&	 *          |   ownable.canHaveAsOwner(this) &&	 *          |   ( (! hasAsOwning(ownable)) ||	 *          |     (ownable.getOwner() == this) )	 */	@Raw	public boolean canHaveAsOwning(@Raw Ownable ownable) {		return (ownable != null) && (ownable.canHaveAsOwner(this))			&& ((!hasAsOwning(ownable)) || (ownable.getOwner() == this));	}	/**	 * Return the number of ownings of this person.	 * 	 * @return  The total number of ownings of this person.	 *          result ==	 *          |   { ownable:Ownable | hasAsOwning(ownable) }.size()	 */	public int getNbOwnings() {		return this.getOwnings().size();	}	public Set<Ownable> getOwnings() {		Set<Ownable> ownables = new HashSet<>();		ownables.addAll(this.dogs);		ownables.addAll(this.paintings);		ownables.addAll(this.cars);		return ownables;	}	/**	 * Add the given dog to the ownings of this person.	 *	 * @param   dog  The dog to be added.	 * @effect  The owner of the given dog is changed to this person.	 *          | dog.changeOwnerTo(this)	 * @throws  IllegalArgumentException [must]	 *          The given dog is not effective.	 *          | dog == null	 */	public void addDog(Dog dog) throws IllegalOwnerException, IllegalArgumentException {		try {			this.dogs.add(dog);			dog.changeOwnerTo(this);		} catch (NullPointerException e) {			assert (dog == null);			throw new IllegalArgumentException("The given dog is not effective");		}	}	/**	 * Remove a dog from the ownings of this person.	 * @param dog  The dog to be removed	 * @throws IllegalArgumentException  The given dog is not effective.	 *                                   | dog == null	 * @throws NoSuchElementException    This person does not own the given dog.	 *                                   | (!hasAsOwning(dog))	 */	public void removeDog(Dog dog) throws IllegalArgumentException, NoSuchElementException {		if (dog == null) {			throw new IllegalArgumentException("The given dog is not effective.");		}		if (!this.dogs.contains(dog)) {			throw new NoSuchElementException("The given dog is not owned by this person.");		}		this.dogs.remove(dog);		if (dog.getOwner() == this) {			dog.removeOwner();		}	}	/**	 * Add the given painting to the ownings of this person.	 *	 * @param   painting  The painting to be added.	 * @effect  The owner of the given painting is changed to this person.	 *          | painting.changeOwnerTo(this)	 * @throws  IllegalArgumentException [must]	 *          The given painting is not effective.	 *          | painting == null	 */	public void addPainting(Painting painting) throws IllegalOwnerException, IllegalArgumentException {		try {			this.paintings.add(painting);			painting.changeOwnerTo(this);		} catch (NullPointerException e) {			assert (painting == null);			throw new IllegalArgumentException("The given painting is not effective");		}	}	/**	 * Remove a painting from the ownings of this person.	 * @param painting  The painting to be removed	 * @throws IllegalArgumentException  The given painting is not effective.	 *                                   | painting == null	 * @throws NoSuchElementException    This person does not own the given painting.	 *                                   | (!hasAsOwning(painting))	 */	public void removePainting(Painting painting) throws IllegalArgumentException, NoSuchElementException {		if (painting == null) {			throw new IllegalArgumentException("The given painting is not effective.");		}		if (!this.paintings.contains(painting)) {			throw new NoSuchElementException("The given painting is not owned by this person.");		}		this.paintings.remove(painting);		if (painting.getOwner() == this) {			painting.removeOwner();		}	}	/**	 * Add the given car to the ownings of this person.	 *	 * @param   car  The car to be added.	 * @effect  The owner of the given car is changed to this person.	 *          | car.changeOwnerTo(this)	 * @throws  IllegalArgumentException [must]	 *          The given car is not effective.	 *          | car == null	 */	public void addCar(Car car) throws IllegalOwnerException, IllegalArgumentException {		try {			this.cars.add(car);			car.changeOwnerTo(this);		} catch (NullPointerException e) {			assert (car == null);			throw new IllegalArgumentException("The given car is not effective");		}	}	/**	 * Remove a car from the ownings of this person.	 * @param car  The car to be removed	 * @throws IllegalArgumentException  The given car is not effective.	 *                                   | car == null	 * @throws NoSuchElementException    This person does not own the given car.	 *                                   | (!hasAsOwning(car))	 */	public void removeCar(Car car) throws IllegalArgumentException, NoSuchElementException {		if (car == null) {			throw new IllegalArgumentException("The given car is not effective.");		}		if (!this.cars.contains(car)) {			throw new NoSuchElementException("The given car is not owned by this person.");		}		this.cars.remove(car);		if (car.getOwner() == this) {			car.removeOwner();		}	}	/**	 * Return the total value of all things owned by this person.	 *	 * @return  The total value of all things owned by this person.	 *          | result ==	 *          |   { ownable:Ownable |	 *          |     hasAsOwning(ownable) }}.getValue().sum()	 * @throws  IllegalStateException	 *          This person is already terminated.	 *          | isTerminated()	 */	public BigDecimal getTotalValue() throws IllegalStateException {		if (isTerminated()) {			throw new IllegalStateException("Person already terminated!");		}		BigDecimal totalValue = BigDecimal.ZERO;		for (Ownable owning : this.getOwnings()) {			totalValue = totalValue.add(owning.getValue());		}		return totalValue;	}		// The methods listed below illustrate different concepts offered in Java	// to retrieve information concerning the class to which an object belongs.	// None of the concepts is superior, meaning that each of the methods	// can be worked out just as well using the other concepts.	// In general, one must be very careful to use these concepts. As it will	// be discussed in later sessions, explicitly asking for the class to which	// an object belongs sometimes has a negative impact on the adaptability	// of software systems.	/**	 * Return the total amount of food needed to feed all dogs	 * owned by this person during the given number of days.	 *	 * @param   days  The given number of days.	 * @return  The total amount of food needed to feed all dogs	 *          owned by this person during the given number of days.	 *          | let	 *          |   myDogs = { dog: Dog | hasAsOwning(dog) }	 *          | in	 *          |   result == {{ myDogs.getFoodAmount()*days }}.sum()	 * @throws  IllegalStateException [must]	 *          This person is already terminated.	 *          | isTerminated()	 * @throws  IllegalArgumentException [must]	 *          This person is not yet terminated and the given number of days	 *          is negative.	 *          | (! this.isTerminated()) && (days < 0)	 */	public BigInteger getTotalFoodAmount(int days) throws IllegalArgumentException, IllegalStateException {		if (isTerminated()) {			throw new IllegalStateException("Person already terminated!");		}		if (days < 0) {			throw new IllegalArgumentException("Negative number of days!");		}		BigInteger totalDailyAmount = BigInteger.ZERO;		for (Dog dog : this.dogs) {			BigInteger currentDailyFoodAmount =					BigInteger.valueOf(dog.getDailyFoodAmount());			totalDailyAmount = totalDailyAmount.add(currentDailyFoodAmount);		}		return totalDailyAmount.multiply(BigInteger.valueOf(days));	}	/**	 * Return the car with the largest motor volume owned by this person.	 *	 * @return  The resulting car is owned by this person.	 *          | hasAsOwning(result)	 * @return  No other car owned by this person has a higher motor volume	 *          than the resulting car	 *          | for each car in Car:	 *          |   if (hasAsOwning(car))	 *          |     then result.getMotorVolume() >= car.getMotorVolume()	 * @throws  IllegalStateException [must]	 *          This person is already terminated.	 *          | isTerminated()	 * @throws  NoSuchElementException [must]	 *          This person is not yet terminated and does not own any car.	 *          | (! this.isTerminated()) &&	 *          | ( for each car in Car: (! hasAsOwning(car)) )	 */	public Car getMostPowerfulCar() throws NoSuchElementException, IllegalStateException {		if (isTerminated()) {			throw new IllegalStateException("Person already terminated!");		}		Car result = null;		for (Car car : this.cars) {			if ((result == null) || (result.getMotorVolume() < car.getMotorVolume())) {				result = car;			}		}		if (result == null) {			throw new NoSuchElementException("Person without cars!");		}		return result;	}	/**	 * Return a painting owned by this person and painted by the given painter.	 *	 * @param	painter  The painter to search for.	 * @return	The resulting painting is owned by this person and painted	 *			by the given painter.	 *			| hasAsOwning(result) &&	 *			| result.getPainter() == painter	 * @throws	IllegalStateException [must]	 * 			This person is already terminated.	 * 			| isTerminated()	 * @throws	NoSuchElementException [must]	 *			This person is not yet terminated and does not own a painting	 *          by the given painter.	 *			| (! this.isTerminated()) &&	 *          | ( for each painting in Painting:	 *			|	  (painting.getPainter() != painter) ||	 *			|	  (! hasAsOwning(painting)) )	 */	public Painting getPaintingBy(Person painter) throws NoSuchElementException, IllegalStateException {		if (isTerminated()) {			throw new IllegalStateException("Person already terminated!");		}		for (Painting painting : this.paintings) {			if (painting.getPainter() == painter) {				return painting;			}		}		throw new NoSuchElementException("Person without paintings of given painter!");	}}