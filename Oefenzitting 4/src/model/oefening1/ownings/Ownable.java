package model.oefening1.ownings;import java.math.BigDecimal;import java.math.BigInteger;import be.kuleuven.cs.som.annotate.*;import model.oefening1.exceptions.*;import model.oefening1.persons.Person;/** * A class of things with a value that can be owned by persons.  *  * @invar   Each ownable must can have its value as its value. *          | canHaveAsValue(getValue()) * @invar   Each ownable can have its owner as its owner. *          | canHaveAsOwner(getOwner()) */public abstract class Ownable {	/**	 * Variable referencing the value of this ownable.	 *	 * @invar   If this ownable is not yet terminated, it can have the referenced	 *          value as its value.	 *          | if (! this.isTerminated())	 *          |   then canHaveAsValue(value)	 * @invar   If this ownable is not terminated, the referenced value must be null.	 *          | if (this.isTerminated())	 *          |   then (value == null)	 */	private BigDecimal value = BigDecimal.ZERO;	/**	 * Variable referencing the owner of this ownable.	 * 	 * @invar   This ownable can have the registered owner	 *          as its owner.	 *          | canHaveAsOwner(owner)	 */	private Person owner = null;		/**	 * Initialize this new ownable with given owner and given value.	 *	 * @param   owner	 *          The owner for this new ownable.	 * @param   value	 *          The value of this new ownable.	 * @effect  The owner of this new ownable is changed to the given	 *          owner.	 *          | changeOwnerTo(owner)	 * @effect  The value of this new ownable is set to the given value.	 *          | setValue(value)	 * @post    This new ownable is not terminated.	 *          | ! new.isTerminated()	 * @throws  IllegalValueException [must]	 *          The given value is not effective.	 *          | (value == null)	 * @note    Constructors for abstract classes are best qualified protected.	 *          Ordinary clients of an abstract class cannot use them to create	 *          objects.	 */	@Model	protected Ownable(Person owner, BigDecimal value)			throws IllegalOwnerException, IllegalValueException {		if (value == null) {			throw new IllegalValueException(this,null);		}		setValue(value);		changeOwnerTo(owner);	}	/**	 * Initialize this new ownable with no owner and a value of 0.	 *	 * @effect  This new ownable is initialized with no owner and	 *          with value 0.	 *          | this(null,BigInteger.ZERO) 	 */	@Model	protected Ownable() {		// No need to invoke the extended constructor here, because		// both characteristics have been initialized to the stated		// values. An invocation would be impossible, because Java		// does not allow us to catch exceptions thrown by that		// constructor.	}	/**	 * Check whether this ownable has been terminated.	 */	@Raw	public boolean isTerminated() {		return getValue() == null;	}	/**	 * Terminate this ownable.	 *	 * @post    This ownable is terminated.	 *          | new.isTerminated()	 * @post    If this ownable has an effective owner upon entry,	 *          that owner no longer owns this ownable upon exit.	 *          | if (hasOwner())	 *          |   then (! (new getOwner()).hasAsOwning(this))	 * @post    The value of this ownable may have changed.	 *          | new.canHaveAsValue(new.getValue())	 */	public void terminate() {		this.removeOwner();		this.setIsTerminated();	}	/**	 * Set the terminated-state for this ownable to true.	 * 	 * @post    The terminated-state of this ownable is true.	 *          | new.isTerminated() == true	 * @post    The value of this ownable is no longer effective.	 *          | new.getValue() == null	 */	protected void setIsTerminated() {		// We do not want to introduce an extra instance variable		// reflecting whether an ownable is terminated.		// Instead, we use a value for the instance variable		// 'value', that is illegal for non-terminated ownables.		try {			this.setValue(null);		} catch (Exception exc) {			assert false;		}	}	/**	 * Return the value of this ownable.	 * 	 * @note    For reasons of simplicity, the value of an ownable	 *          is expressed as a big integer. Obviously, it would	 *          be better to use a class of money amounts.	 */	@Raw	public BigDecimal getValue() {		return this.value;	}	/**	 * Check whether this ownable can have the given value	 * as its value.	 * 	 * @param   value	 *          The value to be checked.	 * @return  True if this ownable is terminated, or if the	 *          given value is effective and not negative;	 *          false otherwise.	 *          | result ==	 *          |   (isTerminated() || 	 *          |    (value != null) &&	 *          |     (value.compareTo(BigInteger.ZERO) >= 0) )	 * @note    In the terminated state, any big integer is acceptable as	 *          the value of an ownable, including negative values and	 *          non-effective values. We do not want to expose that we	 *          use a null-reference for the value to represent the	 *          terminated state.	 */	@Raw	public boolean canHaveAsValue(BigDecimal value) {		try {			return isTerminated() || (value.compareTo(BigDecimal.ZERO) >= 0);		} catch (NullPointerException exc) {			assert (value == null);			return this.isTerminated();		}	}	/**	 * Set the value of this ownable to the given value.	 *	 * @param   value	 *          The new value for this ownable.	 * @post    The value of this ownable is the same as the given value.	 *          | new.getValue() == value	 * @throws  IllegalValueException [must]	 *          The given value is effective and tis ownable cannot have the	 *          given value as its value.	 *          | (value != null) && (! canHaveAsValue(value))	 * @throws  IllegalStateException [must]	 *          This ownable is already terminated.	 *          | isTerminated()	 */	@Raw	public void setValue(BigDecimal value) throws IllegalValueException, IllegalStateException {		if ( (value != null) && (!canHaveAsValue(value)) )			throw new IllegalValueException(this, value);		if (isTerminated())			throw new IllegalStateException("No changes to terminated ownables!");		this.value = value;	}	/**	 * Return the owner of this ownable.	 *   A null reference is returned if this ownable has no owner.	 */	@Raw	public Person getOwner() {		return this.owner;	}	/**	 * Check whether this ownable can have the given owner	 * as its owner.	 *	 * @param   owner	 *          The owner to check.	 * @return  True if the given owner is not effective.	 *          | if (owner == null)	 *          |   then result == true	 * @return  Otherwise, false if this ownable is terminated	 *          or if the given owner is terminated.	 *          | else if ( this.isTerminated() || owner.isTerminated() )	 *          |   then result == false	 * @return  Otherwise, true if the given owner is not the owner	 *          of this ownable.	 *          | else if (this.getOwner() != owner)	 *          |   then result == true	 * @return  Otherwise, true if the given owner has this	 *          ownable as one of its ownings, false otherwise.	 *          | else	 *          |   result == owner.hasAsOwning(this)	 */	@Raw	public boolean canHaveAsOwner(Person owner) {		if (owner == null)			return true;				if (this.isTerminated() || owner.isTerminated()) {			return false;		} else {			return ((this.getOwner() != owner) || owner.hasAsOwning(this));		}	}	/**	 * Check whether this ownable has an owner.	 *	 * @return  True if the owner of this ownable is effective;	 *          false otherwise.	 *          | result == (getOwner() != null)	 */	public boolean hasOwner() {		return getOwner() != null;	}	/**	 * Change the owner of this ownable to the given owner.	 *	 * @param   owner	 *          The new owner for this ownable.	 * @post    The owner of this ownable is the same as the given owner.	 *          | new.getOwner() == owner	 * @post    The given owner has this ownable as one of its ownings.	 *          | (new owner).hasAsOwner(this)	 * @post    The former owner of this ownable, if any, no longer has	 *          this ownable as one of its ownings, except if the given	 *          owner coincedes with the former owner.	 *          | if (hasOwner() && (this.getOwner() != owner))	 *          |   then (! (new getOwner()).hasAsOwning(this)))	 * @throws  IllegalOwnerException [must]	 *          This ownable cannot have the given owner as	 *          its owner.	 *          | ! canHaveAsOwner(owner)	 * @throws  IllegalArgumentException [must]	 *          The given owner is not effective.	 *          | owner == null	 */	@Raw	public void changeOwnerTo(Person owner) throws IllegalOwnerException, IllegalArgumentException {		if (!canHaveAsOwner(owner)) {			throw new IllegalOwnerException(owner, this);		}		if (owner == null) {			throw new IllegalArgumentException("Non-effective owner!");		}		if (this.hasOwner()) {			this.removeOwner();		}		setOwner(owner);	}	/**	 * Remove the owner, if any, from this ownable.	 *	 * @post    This ownable no longer has an owner.	 *          | ! new.hasOwner()	 * @post    The former owner of this ownable, if any, no longer has	 *          this ownable as one of its ownings.	 *          | if (hasOwner())	 *          |   then (! (new getOwner()).hasAsOwning(this))	 */	public void removeOwner() {		this.setOwner(null);	}	/**	 * Set the owner of this ownable to the given owner.	 *	 * @param   owner	 *          The new owner for this ownable.	 * @pre     This ownable does not have an effective owner, or	 *          the owner of this ownable no longer has this ownable	 *          as one of its ownings.	 *          | (! hasOwner()) || (! getOwner().hasAsOwning(this))	 * @pre     This ownable can have the given owner as its owner.	 *          | canHaveAsOwner(owner)	 * @post    The owner of this ownable is the same as the given owner.	 *          | new.getOwner() == owner	 * @note    The first precondition prevents the former owner of	 *          this ownable to turn into a state in which it would	 *          violate one of its class invariants. This is not	 *          allowed, because the former owner is not designated	 *          as a raw object, and therefore must satisfy all its	 *          invariants upon entry and upon exit from this method. 	 */	@Raw	protected void setOwner(Person owner) {		this.owner = owner;	}}