package model.oefening1;import be.kuleuven.cs.som.annotate.Basic;/** * A class of persons involving their name and a marital partner. * * @invar  Each person must have a proper marital status. *         | hasProperMaritalStatus() */public class Person {	/**	 * Variable with the name of this person.	 */	private String name;	/**	 * Variable referencing the spouse of this person.	 */	private Person spouse;	/**	 * Initialize a new person with a given partner.	 *	 * @param   name The name for the new person.	 * @param   partner  The partner for the new person.	 * @post    This new person's name is set to the specified name.	 *          | new.getName() == name	 * @post    The partner is registered as the spouse of this new person.	 *          | new.getSpouse() == partner	 * @post    The new person is registered as the spouse of the partner.	 *          | partner.getSpouse() == this	 *	 * @throws  IllegalArgumentException  The partner is not effective.	 *                                    | partner == null	 * @throws  IllegalPartnerException   The partner is effective, but cannot be registered	 *                                    as the spouse of the new person.	 *                                    | (partner != null) &&	 *                                    |   (partner.isMarried())	 */	public Person(String name, Person partner) throws IllegalArgumentException, IllegalPartnerException {		if (partner == null) {			throw new IllegalArgumentException("The specified partner cannot be null.");		}		this.setName(name);		this.marry(partner);	}	/**	 * Initialize a new unmarried person.	 *	 * @param   name The name for the new person.	 * @post    This new person's name is set to the specified name.	 *          | new.getName() == name	 * @post    The new person is not married.	 *          | ! new.isMarried()	 */	public Person(String name) {		// Impossible to invoke the more general constructor here, because it throws		// an exception.		this.setName(name);		this.setSpouse(null);	}	/**	 * Terminate this person, breaking the marriage in which that person might be involved.	 *	 * @post  If this person was married, its former spouse will no longer be married.	 *        | if (this.isMarried())	 *        |   then ! (new.getSpouse().isMarried())	 *        Equivalent specification: no (living) person can still be married to	 *        this person.	 *        | for each person in (new model.oefening1.Person):	 *        |   (new person).getSpouse() != this	 */	public void terminate() {		divorce();	}	/**	 * Register a marriage between this person and the given partner.	 *	 * @param   partner	 *          The partner for this person.	 * @post    The partner is registered as the spouse of this person.	 *          | new.getSpouse() == partner	 * @post    This person is registered as the spouse of the partner.	 *          | partner.getSpouse() == this	 * @throws  IllegalPartnerException	 *          This person cannot marry the partner.	 *          | ! this.canMarry(partner)	 */	public void marry(Person partner) throws IllegalPartnerException {		if (!canMarry(partner)) {			throw new IllegalPartnerException(this, partner);		}		this.setSpouse(partner);		partner.setSpouse(this);	}	/**	 * Register a divorce between this person and its partner, if any.	 *	 * @post   This person is no longer married.	 *         | ! new.isMarried()	 * @post   The former partner of this person, if any, is no longer married.	 *         | if (this.isMarried())	 *         |   then ! (new.getSpouse().isMarried())	 */	public void divorce() {		if (this.isMarried()) {			this.getSpouse().setSpouse(null);			this.setSpouse(null);		}	}	/**	 * Register a switch of partners between this person and the other person.	 *	 * @param   other	 *          The person to switch partners with.	 * @post    This person is married to the other person.	 *          | new.getSpouse() == other	 * @post    The other person is married to this person.	 *          | (new other).getSpouse() == this	 * @post    This person's spouse is married to the other person's spouse.	 *          | this.getSpouse().getSpouse() == other.getSpouse()	 * @post    The other person's spouse is married to this person's spouse.	 *          | other.getSpouse().getSpouse() == this.getSpouse()	 * @throws  NullPointerException  The other person is not effective.	 *                                | other == null	 */	public void switchPartnerWith(Person other) throws NullPointerException {		Person thisSpouse = this.getSpouse();		Person otherSpouse = other.getSpouse();		this.divorce();		other.divorce();		try {			if (otherSpouse != null)				this.marry(otherSpouse);			if (thisSpouse != null)				other.marry(thisSpouse);		}		catch (IllegalPartnerException exc) {			// This person and the other person are of different gender.			// One of the original spouses is guaranteed to be effective.			try {				this.marry(other);				if ( (thisSpouse != null) && (otherSpouse != null) )					thisSpouse.marry(otherSpouse);			}			catch (IllegalPartnerException exc2) {				// Cannot be thrown.			}		}	}	/**	 * Return the spouse of this person.	 *   A null-reference is returned if this person is not married.	 */	public Person getSpouse() {		return spouse;	}	/**	 * Return a boolean indicating whether this person is married.	 *	 * @return  True if this person references an effective spouse; false otherwise.	 *          | getSpouse() != null	 */	public boolean isMarried() {		return getSpouse() != null;	}	/**	 * Check whether this person has a proper marital status.	 *	 * @return True if this person is not married;	 *         True if this person is married and this person's spouse refers back	 *         to this person as its spouse;	 *         false otherwise.	 *         | if (this.isMarried())	 *         |   then  this.getSpouse().getSpouse() == this	 *         |   else  true	 */	public boolean hasProperMaritalStatus() {		return !this.isMarried() ||				this.getSpouse().getSpouse() == this;	}	/**	 * Check whether this person can marry the given person.	 *	 * @param   person	 *          The partner to check.	 * @return  True if <person> is effective, and if the gender of this person differs	 *          from the gender of <person>, and if both this person and <person> are	 *          not married.	 *          | (person != null) &&	 *          | (this.getGender() != person.getGender()) &&	 *          | (! this.isMarried()) &&	 *          | (! person.isMarried())	 */	public boolean canMarry(Person person) {		try {			return !(this.isMarried() || person.isMarried());		} catch (NullPointerException exc) {			// The other person was not effective.			return false;		}	}	/**	 * Register the given person as the spouse of this person.	 *	 * @param   person	 *          The person to be registered as the spouse of this person.	 * @post    <partner> is registered as the spouse of this person.	 *          | new.getSpouse() == partner	 */	private void setSpouse(Person person) {		this.spouse = person;	}	/**	 * Return the name of this person.	 */	@Basic public String getName() {		return this.name;	}	/**	 * Register the name of this person.	 *	 * @param name	 *        The new value for the name of this person.	 * @post  The name of this person is set to the specified name.	 *        | new.getName() == name	 */	private void setName(String name) {		this.name = name;	}}